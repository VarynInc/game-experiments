<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <title>Demo: Animate sprite</title>

    <script src="https://code.createjs.com/1.0.0/createjs.min.js"></script>
    <script src="./flightData.js"></script>
    <script id="editable">
    "use strict";
    var debug = true;
    var canvas;
    var stage;
    var stageWidth;
    var stageHeight;
    var scaleFactor = 0.5;
    var framerate = 30;
    var framesPerMillisecond = framerate / 1000;
    var millisecondsPerFrame = 1000 / framerate;
    var PIOneEighty = Math.PI / 180;
    var oneEightyPI = 180 / Math.PI;
    var maxAnglePerFrame = 360 / framerate;
    var loader;
    var activeDrawingCanvas = null;
    var priorPoint = null;
    var priorMidPoint = null;
    var arrayOfLostAirplanes = [];
    var arrayOfAlertContainers = [];
    var arrayOfLandingZones = [];
    var airplaneSpriteSheet;
    var lightenDarkenNum = 30;
    var configuration = {
        crashTimeToRemoval: 5,
        minFlightTime: 2,
        airplaneColor: null,
        airplaneTimerColor: null,
        airplaneTimerIntervals: null,
        bossLevelSpawnPositions: null,
        airplaneSprites: null,
        airplaneSeedTime: null,
        airportBackground: null,
        landingZones: null
    };
    var gameData = {
        airplaneNextId: 0,
        totalAirplanesSeen: 0,
        totalAirplanesLanded: 0,
        totalAirplanesLandedOnTime: 0,
        totalAirplanesCrashed: 0,
        nextAirplaneTime: -1,
        currentSeedIndex: 0,
        bossLevelIndex: 0,
        bossLevelPositionIndex: 0,
        level: 0,
        inBossLevel: false,
        availableColors: [],
        airplaneSpawns: null,
        arrayOfAirplanes: []
    }

    function debugLog(message) {
        if (debug) {
            console.log(message);
        }
    }

    function loadConfiguration() {
        configuration.airplaneColor = {
            selectedColor: "#ffffff",
            lineColors: ["#55d1ee", "#ff99cc", "#ffff66", "#660066", "#66ff66", "#cc99ff", "#ff9933", "#3333ff"],
            strokeWidth: 4,
            lineWidth: 4,
            alertColor: {
                fillColor: "#ee0000",
                strokeColor: "#990000",
                strokeWidth: 4
            }
        };
        configuration.airplaneTimerColor = {
            fillColor: ["#55d122", "#d9d824", "#d52424"],
            strokeColor: ["#193d0a", "#4c4b0c", "#460b0b"],
            strokeWidth: 2
        };
        configuration.airplaneSprites = [
            {
                frame: "a-jumbo",
                speed: 1.2,
                score: 1500
            },
            {
                frame: "a-jet",
                speed: 1.1,
                score: 1200
            },
            {
                frame: "a-md",
                speed: 1,
                score: 900
            },
            {
                frame: "a-prop",
                speed: 0.75,
                score: 800
            },
            {
                frame: "a-cub",
                speed: 0.5,
                score: 500
            }
        ];
        configuration.chopperSprites = {
            frame: "chopper",
            speed: 0.5,
            score: 750
        };
        configuration.militarySprites = {
            frame: "a-mil",
            speed: 1.5,
            score: 2000
        };
        configuration.airportBackground = "airport-50.jpg";
        // Landing zones are based on the background. Airplane landing zones are 4 points that
        // define a polygon where the first and second point identify the slope that defined the
        // angle to match the plane landing direction. For chopper landing zone a single point
        // that defines a circle, center point and radius.
        configuration.landingZones = [
            [{x: 980, y: 252}, {x: 970, y: 420}, {x: 1038, y: 424}, {x: 1040, y: 260}],
            [{x: 922, y: 1348}, {x: 928, y: 1184}, {x: 994, y: 1186}, {x: 984, y: 1352}],
            [{x: 1300, y: 342}, {x: 1208, y: 422}, {x: 1256, y: 478}, {x: 1344, y: 394}],
            [{x: 294, y: 1246}, {x: 404, y: 1154}, {x: 444, y: 1200}, {x: 342, y: 1288}],
            [{x: 798, y: 1112, r: 48}]
        ];
        // define the boss level airplane spawns
        configuration.bossLevelSpawnPositions = [
            [
                {type: 7, startPoint: {x: -50, y: stageHeight * 0.2}, finalPosition: { x: stageWidth * 0.5, y: stageHeight * 0.5}},
                {type: 7, startPoint: {x: -50, y: stageHeight * 0.5}, finalPosition: { x: stageWidth * 0.5, y: stageHeight * 0.5}},
                {type: 7, startPoint: {x: -50, y: stageHeight * 0.8}, finalPosition: { x: stageWidth * 0.5, y: stageHeight * 0.5}},
                {type: 7, startPoint: {x: stageWidth + 50, y: stageHeight * 0.2}, finalPosition: { x: stageWidth * 0.5, y: stageHeight * 0.5}},
                {type: 7, startPoint: {x: stageWidth + 50, y: stageHeight * 0.5}, finalPosition: { x: stageWidth * 0.5, y: stageHeight * 0.5}},
                {type: 7, startPoint: {x: stageWidth + 50, y: stageHeight * 0.8}, finalPosition: { x: stageWidth * 0.5, y: stageHeight * 0.5}}
            ],
            [
                {type: 1, startPoint: {x: stageWidth + 30, y: stageHeight * 0.5}, finalPosition: { x: 0, y: stageHeight * 0.5}},
                {type: 1, startPoint: {x: stageWidth + 40, y: stageHeight * 0.4}, finalPosition: { x: 0, y: stageHeight * 0.5}},
                {type: 1, startPoint: {x: stageWidth + 40, y: stageHeight * 0.6}, finalPosition: { x: 0, y: stageHeight * 0.5}},
                {type: 1, startPoint: {x: stageWidth + 50, y: stageHeight * 0.3}, finalPosition: { x: 0, y: stageHeight * 0.5}},
                {type: 1, startPoint: {x: stageWidth + 50, y: stageHeight * 0.7}, finalPosition: { x: 0, y: stageHeight * 0.5}}
            ],
            [
                {type: 2, startPoint: {x: stageWidth + 50, y: stageHeight * 0.5}, finalPosition: { x: 0, y: stageHeight * 0.5}},
                {type: 2, startPoint: {x: stageWidth + 80, y: stageHeight * 0.4}, finalPosition: { x: 0, y: stageHeight * 0.5}},
                {type: 2, startPoint: {x: stageWidth + 80, y: stageHeight * 0.6}, finalPosition: { x: 0, y: stageHeight * 0.5}},
                {type: 2, startPoint: {x: stageWidth + 100, y: stageHeight * 0.3}, finalPosition: { x: 0, y: stageHeight * 0.5}},
                {type: 2, startPoint: {x: stageWidth + 100, y: stageHeight * 0.7}, finalPosition: { x: 0, y: stageHeight * 0.5}}
            ],
            [
                {type: 2, startPoint: {x: stageWidth + 50, y: stageHeight * 0.5}, finalPosition: { x: 0, y: stageHeight * 0.5}},
                {type: 2, startPoint: {x: stageWidth + 80, y: stageHeight * 0.4}, finalPosition: { x: 0, y: stageHeight * 0.5}},
                {type: 2, startPoint: {x: stageWidth + 80, y: stageHeight * 0.6}, finalPosition: { x: 0, y: stageHeight * 0.5}},
                {type: 2, startPoint: {x: stageWidth + 100, y: stageHeight * 0.3}, finalPosition: { x: 0, y: stageHeight * 0.5}},
                {type: 2, startPoint: {x: stageWidth + 100, y: stageHeight * 0.7}, finalPosition: { x: 0, y: stageHeight * 0.5}},
                {type: 2, startPoint: {x: stageWidth + 100, y: stageHeight * 0.2}, finalPosition: { x: 0, y: stageHeight * 0.5}},
                {type: 2, startPoint: {x: stageWidth + 100, y: stageHeight * 0.8}, finalPosition: { x: 0, y: stageHeight * 0.5}}
            ]
        ];
        // Define game levels:
        configuration.airplaneSeedTime = [
            { boss: false, count:  3, seedTime: 25000, max: 2, militaryCount: 0, chopperCount: 0, alertTime: 5000 },
            { boss: false, count:  5, seedTime: 20000, max: 3, militaryCount: 0, chopperCount: 0, alertTime: 5000 },
            { boss: false, count:  5, seedTime: 17000, max: 4, militaryCount: 0, chopperCount: 1, alertTime: 5000 },
            { boss: false, count:  7, seedTime: 12000, max: 5, militaryCount: 0, chopperCount: 1, alertTime: 3000 },
            { boss: true,  count:  0, seedTime:     0, max: 6, militaryCount: 0, chopperCount: 0, alertTime: 1000 },
            { boss: false, count: 10, seedTime: 12000, max: 6, militaryCount: 1, chopperCount: 1, alertTime: 3000 },
            { boss: true,  count:  0, seedTime:     0, max: 5, militaryCount: 0, chopperCount: 0, alertTime: 1000 },
            { boss: false, count: 10, seedTime:  7500, max: 8, militaryCount: 1, chopperCount: 2, alertTime: 3000 },
            { boss: true,  count:  0, seedTime:     0, max: 6, militaryCount: 0, chopperCount: 0, alertTime: 1000 },
            { boss: false, count: 10, seedTime:  7500, max: 8, militaryCount: 2, chopperCount: 2, alertTime: 3000 },
            { boss: true,  count:  0, seedTime:     0, max: 8, militaryCount: 0, chopperCount: 0, alertTime: 1000 },
            { boss: false, count: 10, seedTime:  5000, max: 8, militaryCount: 2, chopperCount: 3, alertTime: 2000 },
            { boss: false, count: 10, seedTime:  5000, max: 8, militaryCount: 3, chopperCount: 3, alertTime: 1000 }
        ];
    };

    /**
     * Initialize the game and start loading assets based on the available resolution.
     */
    function init() {
        canvas = document.getElementById("myCanvas");

        // check to see if we are running in a browser with touch support
        stage = new createjs.Stage(canvas);
        stage.autoClear = true;
        stage.enableDOMEvents(true);
        stageWidth = stage.canvas.width;
        stageHeight = stage.canvas.height;

        loadConfiguration();

        createjs.Touch.enable(stage);
        createjs.Ticker.framerate = framerate;

        loadAssets();
    }

    /**
     * Start loading assets based on the available resolution. When everything is loaded,
     * `handleLoadComplete` is called.
     */
     function loadAssets() {
        loader = new createjs.LoadQueue(false);
        loader.addEventListener("complete", handleLoadComplete);
        loader.loadManifest([
            { src: "game-spritesheet.png", id: "game-sprites" },
            { src: "game-spritesheet.json", id: "game-spriteframes" },
            { src: configuration.airportBackground, id: "background" }
        ],
        true, "./");
    }

    function getNextAirplane() {
        var nextAirplaneType;

        if (gameData.inBossLevel && configuration.bossLevelSpawnPositions[gameData.bossLevelIndex].length > 0) {
            nextAirplaneType = configuration.bossLevelSpawnPositions[gameData.bossLevelIndex][gameData.bossLevelPositionIndex].type;
        } else if (gameData.airplaneSpawns.length > 0) {
            nextAirplaneType = gameData.airplaneSpawns.shift();
        } else {
            nextAirplaneType = 1 + Math.floor(Math.random() * configuration.airplaneSprites.length);
        }
        if (nextAirplaneType === 1) {
            return configuration.chopperSprites;
        } else if (nextAirplaneType === 2) {
            return configuration.militarySprites;
        } else {
            return configuration.airplaneSprites[nextAirplaneType - 3];
        }
    }

    function showGUI() {
        var scoreField = new createjs.Text("0 / 0", "bold 48px Arial", "#FFFFFF");
        scoreField.maxWidth = 80;
        scoreField.name = "score";
        scoreField.textAlign = "center";
        scoreField.textBaseline = "middle";
        scoreField.x = canvas.width * 0.92;
        scoreField.y = canvas.height * 0.92;
        stage.addChild(scoreField);

        var crashField = new createjs.Text("0", "bold 48px Arial", "#FFFFFF");
        crashField.maxWidth = 50;
        crashField.name = "crashes";
        crashField.textAlign = "center";
        crashField.textBaseline = "middle";
        crashField.x = canvas.width * 0.08;
        crashField.y = canvas.height * 0.92;
        stage.addChild(crashField);
    }

    function updateScore() {
        var scoreField = stage.getChildByName("score");
        if (scoreField != null) {
            scoreField.text = gameData.totalAirplanesSeen.toString() + " / " + gameData.totalAirplanesLanded;
        }
    }

    function updateCrashes() {
        var crashField = stage.getChildByName("crashes");
        if (crashField != null) {
            crashField.text = gameData.totalAirplanesCrashed.toString();
        }
    }

    function lightenDarkenColor(color, amount) {
        var colors = [parseInt(color.substr(1, 2), 16), parseInt(color.substr(3, 2), 16), parseInt(color.substr(5, 2), 16)];
        var newHexColors = [];

        for (var i = 0; i < colors.length; i++) {
            colors[i] = Math.floor(colors[i] * (1 - (amount / 100)));
            if (colors[i] > 255) {
                colors[i] = 255;
            }
            newHexColors[i] = colors[i].toString(Number(16))
            if(newHexColors[i].length == 1) {
                newHexColors[i] = "0" + newHexColors[i];
            }
        }

        return "#" + newHexColors[0] + newHexColors[1] + newHexColors[2];
    }

    function loadLineColor(airplane) {
       if (gameData.availableColors.length == 0) {
           for (var i = 0; i < configuration.airplaneColor.lineColors.length; i++) {
               gameData.availableColors[i] = configuration.airplaneColor.lineColors[i];
           }
       }
       airplane.highlightColor = lightenDarkenColor(gameData.availableColors[0], -lightenDarkenNum);
       airplane.highlightStrokeColor = lightenDarkenColor(gameData.availableColors[0], lightenDarkenNum);
       airplane.lineColor = gameData.availableColors.shift();
    }

    function createAirplane(currentTime) {
        var airplaneSize;
        var airplaneSprite;
        gameData.airplaneNextId += 1;
        var nextPlaneType = getNextAirplane();
        var airplaneFrame = nextPlaneType.frame;
        var longestSide = 0;
        var airplane = {
            active: false,
            speed: nextPlaneType.speed,
            score: nextPlaneType.score,
            updateInterval: longestSide * 0.5,
            type: airplaneFrame,
            id: gameData.airplaneNextId,
            flightData: flightData.getNextFlightNumber(airplaneFrame),
            timeoutId: 0,
            crashTimeout: configuration.crashTimeToRemoval,
            flightTime: 0,
            isCrashed: false,
            isLanding: false,
            sprite: null,
            shadow: null,
            highlight: null,
            x: 0,
            y: 0,
            rotation: 0,
            width: 0,
            height: 0,
            elevation: 50,
            highlightColor: null,
            highlightStrokeColor: null,
            lineColor: null,
            range: null,
            alertContainer: null,
            graphicsFillCommand: null,
            graphicsStrokeCommand: null,
            activeTime: 0,
            scheduledArrival: new Date(Date.now() + (1000 * 60 * (1 / nextPlaneType.speed))), // TODO: figure out what makes sense for scheduled arrival times
            arrivalTime: 0,
            arrivalTimerShape: null,
            arrivalTimerShapeOffset: null,
            arrivalTimerStrokeCommand: null,
            arrivalTimerFillCommand: null
        };

        airplane.createSprite = function(parentContainer, airplaneFrame) {
            // airplane visual representation is a sprite animation
            airplaneSprite = new createjs.Sprite(airplaneSpriteSheet, airplaneFrame);
            if (airplaneSprite != null) {
                this.sprite = airplaneSprite;
                airplaneSprite.airplane = this;

                // Container will hold all airplane visual assets: sprite, shadow, track, highlight, effects.
                var airplaneContainer = new createjs.Container();
                airplaneContainer.x = 0;
                airplaneContainer.y = 0;
                airplaneContainer.width = stageWidth;
                airplaneContainer.height = stageHeight;

                airplaneSize = airplaneSprite.getBounds();
                airplaneSprite.width = airplaneSize.width;
                airplaneSprite.height = airplaneSize.height;
                airplaneSprite.regX = airplaneSize.width * 0.5;
                airplaneSprite.regY = airplaneSize.height * 0.5;

                this.width = airplaneSize.width;
                this.height = airplaneSize.height;
                longestSide = Math.max(airplaneSize.width, airplaneSize.height);
                this.updateInterval = longestSide * 0.5;
                this.radius = longestSide * 0.6;
                this.range = {
                    x: -1 * airplaneSize.width,
                    y: -1 * airplaneSize.height,
                    width: stageWidth + airplaneSize.width,
                    height: stageHeight + airplaneSize.height
                };

                // shadow of the airplane
                var airplaneShadow = airplaneSprite.clone();
                var shadowHeight = this.elevation;
                airplaneShadow.name = "shadow";
                airplaneShadow.alpha = 0.8;
                airplaneShadow.filters = [
                    new createjs.ColorFilter(0, 0, 0, 1, 0, 0, 0),
                    new createjs.BlurFilter(5, 5, 10)
                ];
                airplaneShadow.cache(0, 0, airplaneSize.width + shadowHeight, airplaneSize.height + shadowHeight);
                this.shadow = airplaneShadow;

                // Shape to hold the flight path and an array to record each point on the flight path
                var drawingCanvas = new createjs.Shape();
                drawingCanvas.name = "flight-path";
                drawingCanvas.flightPath = [];
                this.flightPathIndex = 0;

                // Shape to hold the arrival time count-down timer
                var arrivalTimerGraphics = new createjs.Graphics();
                var arrivalTimerShape = new createjs.Shape(arrivalTimerGraphics);
                arrivalTimerShape.name = "arrival-timer";
                arrivalTimerGraphics.setStrokeStyle(configuration.airplaneTimerColor.strokeWidth);
                this.arrivalTimerStrokeCommand = arrivalTimerGraphics.beginStroke(configuration.airplaneTimerColor.strokeColor[0]).command;
                this.arrivalTimerFillCommand = arrivalTimerGraphics.beginFill(configuration.airplaneTimerColor.fillColor[0]).command;
                arrivalTimerGraphics.drawRect(0, 0, this.width, 12 * scaleFactor);
                arrivalTimerShape.alpha = 0.6;
                this.arrivalTimerShapeOffset = {
                    x: 0 - (this.width * 0.5),
                    y: 0 + (this.height * 0.5 * 1.05)
                };
                this.arrivalTimerShape = arrivalTimerShape;

                // draw the highlight circle
                var graphics = new createjs.Graphics();
                var highlight = new createjs.Shape(graphics);
                graphics.setStrokeStyle(configuration.airplaneColor.strokeWidth);
                this.graphicsStrokeCommand = graphics.beginStroke(airplane.highlightStrokeColor).command;
                this.graphicsFillCommand = graphics.beginFill(airplane.highlightColor).command;
                graphics.drawCircle(0, 0, this.radius * 1.05);
                this.highlight = highlight;

                // define the hit area for the sprite by reusing the highlight
                var hitarea = highlight.clone();
                var radius = this.radius * 1.15; // make the hit area a little larger than the actual airplane radius
                hitarea.setTransform(0, 0, 1, 1, 0, 0, 0, -1 * airplaneSprite.regX, -1 * airplaneSprite.regY);
                airplaneSprite.hitArea = hitarea;

                highlight.alpha = 0.5;
                highlight.visible = true;
                highlight.name = "highlight";
                highlight.cache(longestSide * -1, longestSide * -1, 2 * longestSide, 2 * longestSide);
                createjs.Tween.get(highlight, { loop: -1 })
                .to({ alpha: 0.1 }, 1000, createjs.Ease.getElasticIn(2, 5))
                .to({ alpha: 0.5 }, 1000, createjs.Ease.getElasticIn(2, 5));

                // add DisplayObjects in drawing order
                airplaneSprite.mouseChildren = false;
                airplaneContainer.addChild(airplaneShadow);
                airplaneContainer.addChild(drawingCanvas);
                airplaneContainer.addChild(highlight);
                airplaneContainer.addChild(arrivalTimerShape);
                airplaneContainer.addChild(airplaneSprite);
                parentContainer.addChild(airplaneContainer);
            }
        };

        // highlight
        airplane.changeHighlightColor = function (newFillColor, newStrokeColor) {
            if (this.graphicsFillCommand != null && newFillColor) {
                this.graphicsFillCommand.style = newFillColor;
            }
            if (this.graphicsStrokeCommand != null && newStrokeColor) {
                this.graphicsStrokeCommand.style = newStrokeColor;
            }
            if (this.highlight != null) {
                this.highlight.updateCache();
            }
        };


        airplane.setHighlight = function () {
            this.changeHighlightColor(airplane.highlightColor, airplane.highlightStrokeColor);
        };

        airplane.setSelected = function () {
            this.changeHighlightColor(configuration.airplaneColor.selectedColor, airplane.highlightStrokeColor);
        };

        airplane.setAlert = function () {
            this.changeHighlightColor(configuration.airplaneColor.alertColor.fillColor, configuration.airplaneColor.alertColor.strokeColor);
        };


        airplane.setWarning = function () {
            // this.changeHighlightColor(configuration.airplaneWarning.fillColor, configuration.airplaneWarning.strokeColor);
            // after warning clears set the prior highlight back, that that means we need to know what it was.
            // airplane.timeoutId = window.setTimeout(airplane.setHighlight.bind(airplane), 3000);
        };

        /**
         * Move the airplane and it children sprites to the indicated point on the screen.
         * @param Point A point {x, y}
         */
        airplane.setPosition = function(point) {
            var sprite = this.sprite;
            var airplaneContainer = sprite.parent;

            this.x = point.x;
            this.y = point.y;

            if (sprite != null) {
                sprite.x = this.x;
                sprite.y = this.y;
            }
            sprite = this.shadow;
            if (sprite != null) {
                var shadowHeight = this.elevation;
                sprite.x = this.x + shadowHeight;
                sprite.y = this.y + shadowHeight;
                sprite.alpha = 0.2; // 2 / shadowHeight;
            }
            sprite = airplane.highlight;
            if (sprite != null) {
                sprite.x = this.x;
                sprite.y = this.y;
            }
            sprite = airplane.arrivalTimerShape;
            if (sprite != null) {
                sprite.x = this.x + this.arrivalTimerShapeOffset.x;
                sprite.y = this.y + this.arrivalTimerShapeOffset.y;
            }
        };

        /**
         * Boss level starting positions are predetermined and require different initialization
         * than regular level airplanes.
         */
        airplane.setBossLevelStartPosition = function (currentTime) {
            var nextSpawn = configuration.bossLevelSpawnPositions[gameData.bossLevelIndex][gameData.bossLevelPositionIndex];
            gameData.bossLevelPositionIndex += 1;
            this.activeTime = currentTime + configuration.airplaneSeedTime[gameData.currentSeedIndex].alertTime;
            this.setPosition(nextSpawn.startPoint);
            this.movePlane(nextSpawn.finalPosition);
            this.updatePosition(0, framesPerMillisecond);
        };

        /**
         * Set the starting position for an airplane on a regular level by choosing a random
         * location just slightly off the screen.
         */
        airplane.setStartPosition = function () {
            var quadrant = Math.floor(Math.random() * 4); // determines which side airplane will enter from
            var startPoint = {
                x: 0,
                y: 0
            }
            var finalPosition = {
                x: 0,
                y: 0
            };

            if (quadrant < 2) {
                // airplane coming from either top or below
                startPoint.x = Math.floor(Math.random() * canvas.width);
                finalPosition.x = Math.floor(Math.random() * canvas.width);

                if (quadrant === 0) {
                    // airplane coming from top
                    startPoint.y = 0 - this.height;
                    finalPosition.y = canvas.height + this.height;
                } else {
                    // airplane coming from below
                    startPoint.y = canvas.height + this.height;
                    finalPosition.y = 0 - this.height;
                }
            } else {
                // airplane coming from either right or left
                startPoint.y = Math.floor(Math.random() * canvas.height);
                finalPosition.y = Math.floor(Math.random() * canvas.height);

                if (quadrant === 2) {
                    // airplane coming from left
                    startPoint.x = 0 - this.height;
                    finalPosition.x = canvas.width + this.height;
                } else {
                    // airplane coming from right
                    startPoint.x = canvas.width + this.height;
                    finalPosition.x = 0 - this.height;
                }
            }
            this.activeTime = currentTime + configuration.airplaneSeedTime[gameData.currentSeedIndex].alertTime;
            this.setPosition(startPoint);
            this.movePlane(finalPosition);
            // debugLog("A " + this.id + " start(" + this.x + "," + this.y + ") going to (" + finalPosition.x + "," + finalPosition.y + ") at angle " + this.rotation);
            this.updatePosition(0, framesPerMillisecond);
        };

        // time is running time since started. DeltaTime is milliseconds since last tick.
        // Return true if we should continue updating this position.
        airplane.updatePosition = function(time, deltaTime) {
            var airplaneContainer = this.sprite.parent;
            if (this.isCrashed) {
                this.crashTimeout -= deltaTime;
                if (airplaneContainer != null) {
                    airplaneContainer.alpha = this.crashTimeout / configuration.crashTimeToRemoval;
                }
                if (this.crashTimeout <= 0) {
                    this.removeFromGame();
                }
                return true;
            }
            if (airplaneContainer != null) {
                var drawingCanvas = getAirplaneFlightPathCanvas(this);
                if (drawingCanvas != null) {
                    var flightPath = drawingCanvas.flightPath;
                    if (flightPath.length > 0) {
                        if (this.flightPathIndex >= flightPath.length) {
                            // ran out the path, clear it
                            this.clearFlightPath(drawingCanvas);
                        } else {
                            // we have a flight path to trace.
                            // examine each point until we find a point in front in current direction, +/- 15 degrees
                            // if no point, flight path is bad, clear it
                            var nextPoint = null;
                            var d;
                            while (this.flightPathIndex < flightPath.length) {
                                nextPoint = flightPath[this.flightPathIndex];
                                d = distanceBetweenPoints(nextPoint, airplane);
                                if (d < this.updateInterval) {
                                    // distance to next point is too small or we passed it, ignore it and get the next point
                                    this.flightPathIndex++;
                                } else {
                                    break;
                                }
                            }
                            if (nextPoint != null) {
                                // compute what the angle will be to the next point and compare it with the current angle
                                var angle = angleOfLine(airplane.x - nextPoint.x, airplane.y - nextPoint.y);
                                var deltaAngle = normalizeAngleDifference(airplane.rotation, angle);
                                if (Math.abs(deltaAngle) <= maxAnglePerFrame) {
                                    this.movePlane(nextPoint);
                                } else {
                                    // if new angle is too great then flight path is no good, clear it
                                    // debugLog("Next point no good, R=" + airplane.rotation + ", dA=" + deltaAngle + ", max=" + maxAnglePerFrame);
                                    this.clearFlightPath(drawingCanvas);
                                }
                            }
                        }
                    }
                }
                var radians = this.rotation * PIOneEighty;
                var timeSpeedAdjustment = this.speed * (framesPerMillisecond / deltaTime);
                this.setPosition({
                    x: this.x + (Math.sin(radians) * timeSpeedAdjustment),
                    y: this.y - (Math.cos(radians) * timeSpeedAdjustment)
                })
                this.flightTime += deltaTime;
            }
            return (this.flightTime < configuration.minFlightTime) || this.isVisible();
        };

        airplane.updateArrivalTimer = function(time, deltaTime) {
            var arrivalPercent;
            var expectedArrival = this.scheduledArrival.getTime();
            var timeRemaining = expectedArrival - Date.now();
            var colorIndex = 0;
            var arrivalTimerGraphics = this.arrivalTimerShape.graphics;

            if (timeRemaining > 0 && arrivalTimerGraphics != null) {
                arrivalPercent = timeRemaining / (expectedArrival - this.activeTime);
                if (arrivalPercent < 0.3333) {
                    colorIndex = 2;
                } else if (arrivalPercent < 0.5) {
                    colorIndex = 1;
                }
                this.arrivalTimerStrokeCommand.style = configuration.airplaneTimerColor.strokeColor[colorIndex];
                this.arrivalTimerFillCommand.style = configuration.airplaneTimerColor.fillColor[colorIndex];
                arrivalTimerGraphics.drawRect(0, 0, this.width * arrivalPercent, 12 * scaleFactor);
                this.arrivalTimerShape.alpha = 0.6;
            } else {
                this.arrivalTimerShape.visible = false;
            }
        };

        /**
         * Determine if the airplane is completely visible on the screen. This uses
         * `.range` which is pre-computed to include the airplanes width and height.
         * @return boolean True if completely on screen, otherwise false.
         */
        airplane.isVisible = function() {
            return this.x > this.range.x
                && this.x < this.range.width
                && this.y > this.range.y
                && this.y < this.range.height;
        };

        /**
         * Test if the airplane aligns with a landing zone. If it does, the landing sequence
         * is started.
         * @return boolean True if the landing sequence was started, otherwise false.
         */
        airplane.isAlignedForLanding = function() {
            var i;
            var zone;
            var isAligned = false;
            var isChopper = false;
            for (i = 0; i < arrayOfLandingZones.length; i ++) {
                zone = arrayOfLandingZones[i];
                if (airplane.type == "chopper" && zone.circle != null) {
                    isChopper = true;
                    isAligned = distanceBetweenPoints(airplane, zone.circle) <= zone.circle.r;
                } else if (airplane.type != "chopper" && zone.polygon != null) {
                    isAligned = pointInsidePolygon(this, zone.polygon) && slopeMatch(this, zone);
                }
                if (isAligned) {
                    this.isLanding = true;
                    this.arrivalTime = Date.now();
                    this.landingScore();
                    zone.landedCount += 1;
                    this.arrivalTimerShape.visible = false;
                    this.clearFlightPath(null);
                    this.highlight.visible = false;
                    updateScore();
                    var scaleTo = 0.75;
                    if (isChopper) {
                        // Chopper landing sequence
                        airplane.speed = 0;
                        createjs.Tween.get(this)
                            .to({scaleX: scaleTo, scaleY: scaleTo, x: zone.circle.x, y: zone.circle.y, elevation: 5}, 4000, createjs.Ease.quadOut)
                            .wait(1000)
                            .call(function(airplane) {
                                airplane.removeFromGame();
                            }, [this]);
                        createjs.Tween.get(this.sprite)
                            .to({scaleX: scaleTo, scaleY: scaleTo, x: zone.circle.x, y: zone.circle.y}, 4000, createjs.Ease.quadOut);
                        createjs.Tween.get(this.shadow, { onChange: function(event) {
                                    event.target.target.alpha= 1;
                                    event.target.target.updateCache();
                                }})
                            .to({scaleX: scaleTo, scaleY: scaleTo, x: zone.circle.x, y: zone.circle.y, alpha: 1}, 4000, createjs.Ease.quadOut);
                    } else {
                        // Airplane landing sequence
                        var speedUp = this.speed * 1.8;
                        var speedDown = 0.1;
                        var deltaAngle = (zone.landingRotation - this.rotation) % 360;
 
        				if (deltaAngle > 180) {
                            deltaAngle -= 360;
                        } else if (deltaAngle < -180) {
                            deltaAngle += 360;
                        }
                        deltaAngle = this.rotation + deltaAngle;
                        createjs.Tween.get(this)
                            .to({rotation: deltaAngle, speed: speedUp}, 1000, createjs.Ease.quadIn)
                            .to({elevation: 5}, 3000, createjs.Ease.quadIn)
                            .to({speed: 0.1}, 4000, createjs.Ease.quadOut)
                            .wait(1000)
                            .call(function(airplane) {
                                airplane.removeFromGame();
                            }, [this]);
                        createjs.Tween.get(this.sprite)
                            .to({rotation: deltaAngle}, 1000, createjs.Ease.quadIn)
                            .to({scaleX: scaleTo, scaleY: scaleTo}, 3000, createjs.Ease.quadIn);
                        createjs.Tween.get(this.shadow)
                            .to({rotation: deltaAngle}, 1000, createjs.Ease.quadIn)
                            .to({scaleX: scaleTo, scaleY: scaleTo, alpha: 1}, 3000, createjs.Ease.quadIn);
                    }
                    return true;
                }
            }
            return false;
        };

        airplane.landingScore = function() {
            var timeRemaining = this.scheduledArrival.getTime() - Date.now();
            var isOnTime = timeRemaining >= 0;
            var landingScore = this.score;
            var bonusScore = 0;
            var bonusDivisor;
            gameData.totalAirplanesLanded += 1;

            // award more bonus time value for the more valuable planes
            if (landingScore < 900) {
                bonusDivisor = 800
            } else if (landingScore < 1200) {
                bonusDivisor = 200;
            } else {
                bonusDivisor = 100;
            }
            if (isOnTime) {
                gameData.totalAirplanesLandedOnTime += 1;
                bonusScore = Math.floor(timeRemaining / bonusDivisor);
            }
            // debugLog("Landing " + this.id + " score " + landingScore + " on-time bonus " + bonusScore + " TR=" + timeRemaining);
            return landingScore + bonusScore;
        };

        airplane.setCrashed = function() {
            this.isCrashed = true;
            if (this.arrivalTimerShape != null) {
                this.arrivalTimerShape.visible = false;
            }
            if (this.alertContainer != null) {
                window.clearTimeout(this.alertTimeout);
                this.alertTimeout = 0;
                this.alertContainer.visible = false;
                this.alertContainer = null;
            }
            this.crashTimeout = configuration.crashTimeToRemoval;
            this.setAlert();
        };

        airplane.removeFromGame = function() {
            gameData.availableColors.push(airplane.lineColor);
            var airplaneIndex = airplaneIndexFromId(this.id);
            if (airplaneIndex >= 0) {
                gameData.arrayOfAirplanes.splice(airplaneIndex, 1);
            }
            if (this.timeoutId > 0) {
                window.clearTimeout(this.timeoutId);
                this.timeoutId = 0;
            }
            this.sprite.removeAllEventListeners();
            this.sprite.airplane = null;
            this.sprite.scaleX = 1;
            this.sprite.scaleY = 1;
            var airplaneContainer = this.sprite.parent;
            if (airplaneContainer != null) {
                var highlight = airplaneContainer.getChildByName("highlight");
                if (highlight != null) {
                    createjs.Tween.removeTweens(highlight);
                }
                airplaneContainer.removeAllChildren();
                stage.removeChild(airplaneContainer);
            }
            this.sprite = null;
            this.shadow = null;
            this.highlight = null;
            this.arrivalTimerShape = null;
        };

        airplane.clearFlightPath = function(drawingCanvas) {
            if (drawingCanvas == null) {
                drawingCanvas = getAirplaneFlightPathCanvas(this);
            }
            drawingCanvas.graphics.clear();
            drawingCanvas.flightPath = [];
            this.flightPathIndex = 0;
        };

        /**
         * This is the click handler when the user clicks/taps on an airplane.
         */
        airplane.activate = function(event) {
            if (!event.primary) { return; }

            // clear the prior drawing on this airplane
            var airplaneSprite = event.target;
            if (airplaneSprite != null) {
                var airplane = airplaneSprite.airplane;
                if (airplane.isCrashed || airplane.isLanding) {
                    return;
                }
                var drawingCanvas = getAirplaneFlightPathCanvas(airplane);
                airplane.clearFlightPath(drawingCanvas);
                activeDrawingCanvas = drawingCanvas;

                airplane.setSelected();

                // register the starting point and track the mouse
                priorPoint = new createjs.Point(stage.mouseX, stage.mouseY);
                priorMidPoint = priorPoint.clone();
                airplaneSprite.addEventListener("pressmove", airplane.handleMouseMove);
                airplaneSprite.addEventListener("pressup", airplane.handleMouseUp);
            }
        };

        airplane.handleMouseMove = function(event) {
            if (!event.primary) { return; }
            var airplaneSprite = event.target;
            if (airplaneSprite != null) {
                var airplane = airplaneSprite.airplane;
                if (airplane.isCrashed || airplane.isLanding) {
                    return;
                }
                if (activeDrawingCanvas != null) {
                    var mouseX = stage.mouseX;
                    var mouseY = stage.mouseY;
                    var midPoint = new createjs.Point((priorPoint.x + mouseX) / 2, (priorPoint.y + mouseY) / 2);

                    activeDrawingCanvas.graphics
                        .setStrokeStyle(configuration.airplaneColor.lineWidth, 'round', 'round')
                        .beginStroke(airplane.lineColor)
                        .moveTo(midPoint.x, midPoint.y)
                        .curveTo(priorPoint.x, priorPoint.y, priorMidPoint.x, priorMidPoint.y);

                    priorPoint.x = mouseX;
                    priorPoint.y = mouseY;
                    priorMidPoint.x = midPoint.x;
                    priorMidPoint.y = midPoint.y;
                    activeDrawingCanvas.flightPath.push({x: mouseX, y: mouseY});
                }
            }
        };

        airplane.handleMouseUp = function(event) {
            if (!event.primary) { return; }

            activeDrawingCanvas = null;
            priorPoint = null;
            priorMidPoint = null;
            var airplaneSprite = event.target;
            if (airplaneSprite != null) {
                var airplane = airplaneSprite.airplane;
                // stop tracking mouse
                airplaneSprite.removeEventListener("pressmove", airplane.handleMouseMove);
                airplaneSprite.removeEventListener("pressup", airplane.handleMouseUp);
                airplane.setHighlight();
            }
        };

        /**
         * Update rotation of airplane to point to target point. This assumes the
         * target point has already been checked to make sure it is within some degree
         * of rotational tolerance.
         */
        airplane.movePlane = function (toPosition) {
            this.rotation = angleOfLine(this.x - toPosition.x, this.y - toPosition.y);
            this.sprite.rotation = this.rotation;
            this.shadow.rotation = this.rotation;
        };

        airplane.toString = function() {
            return "ID: " + this.id + " type: " + this.type + " flight time: " + this.flightTime + (this.isCrashed ? " CRASHED" : "");
        };

        loadLineColor(airplane);
        airplane.createSprite(stage, airplaneFrame);

        // position plane in its parent container
        airplane.sprite.addEventListener("mousedown", airplane.activate.bind(airplane));
        gameData.arrayOfAirplanes.push(airplane);
        if (gameData.inBossLevel) {
            airplane.setBossLevelStartPosition(currentTime);
        } else {
            airplane.setStartPosition(currentTime);
            showFlightStatus(airplane);
        }
        return airplane;
    }

    function airplaneIndexFromId(airplaneId) {
        for (var index = 0; index < gameData.arrayOfAirplanes.length; index ++) {
            if (airplaneId == gameData.arrayOfAirplanes[index].id) {
                return index;
            }
        }
        return 0;
    }

    function getAirplaneFlightPathCanvas(airplane) {
        if (airplane != null && airplane.sprite != null && airplane.sprite.parent != null) {
            return airplane.sprite.parent.getChildByName("flight-path");
        }
        return null;
    }

    function updateAirplanePosition(time, deltaTime) {
        gameData.arrayOfAirplanes.forEach(function(airplane) {
            if (airplane.active) {
                if ( ! airplane.updatePosition(time, deltaTime)) {
                    arrayOfLostAirplanes.push(airplane);
                } else if (! (airplane.isCrashed || airplane.isLanding)) {
                    airplane.updateArrivalTimer(time, deltaTime);
                }
            } else if (time >= airplane.activeTime) {
                airplane.active = true;
                airplane.activeTime = Date.now();
                gameData.totalAirplanesSeen ++;
                updateScore();
            }
        });
    }

    function removeLostAirplanes() {
        arrayOfLostAirplanes.forEach(function(airplane) {
            airplane.removeFromGame();
        });
        arrayOfLostAirplanes = [];
    }

    function generateSpawns() {
        // generates all airplane spawns for the current level
        var currentSeedIndex = gameData.currentSeedIndex;
        var currentSeed = configuration.airplaneSeedTime[currentSeedIndex];
        var totalSpawns = currentSeed.count; // total number of airplanes to spawn for this level
        var i;
        var nextSpawn;
        var duplicateSpawnCounter;
        var numberOfSpawns;
        var airplaneSpawns = [];
        for (i = 0; i < totalSpawns; i ++) {
            airplaneSpawns[i] = 0;
        }
        // Seed choppers
        if (currentSeed.chopperCount > 0) {
            numberOfSpawns = Math.min(currentSeed.chopperCount, totalSpawns);
            for (i = 0; i < numberOfSpawns; i++) {
                duplicateSpawnCounter = 10;
                do {
                    nextSpawn = Math.floor(Math.random() * totalSpawns);
                    // makes sure we haven't already assigned this spawn
                    if (airplaneSpawns[nextSpawn] === 0) {
                        airplaneSpawns[nextSpawn] = 1;
                        duplicateSpawnCounter = 0;
                    } else {
                        duplicateSpawnCounter --;
                    }
                } while (duplicateSpawnCounter > 0);
            }
        }
        // Seed military jets
        if (currentSeed.militaryCount > 0) {
            numberOfSpawns = Math.min(currentSeed.militaryCount, totalSpawns - currentSeed.chopperCount);
            for (i = 0; i < currentSeed.militaryCount; i++) {
                duplicateSpawnCounter = 10;
                do {
                    nextSpawn = Math.floor(Math.random() * totalSpawns);
                    // makes sure we haven't already assigned this spawn
                    if (airplaneSpawns[nextSpawn] === 0) {
                        airplaneSpawns[nextSpawn] = 2;
                        duplicateSpawnCounter = 0;
                    } else {
                        duplicateSpawnCounter --;
                    }
                } while (duplicateSpawnCounter > 0);
            }
        }
        // Seed any unassigned spawns to a random airplane
        for (i = 0; i < totalSpawns; i ++) {
            if (airplaneSpawns[i] === 0) {
                airplaneSpawns[i] = 3 + Math.floor(Math.random() * configuration.airplaneSprites.length);
            }
        }
        gameData.airplaneSpawns = airplaneSpawns;
    }

    function seedNextAirplane(currentTime, deltaTime) {
        var currentSeedIndex = gameData.currentSeedIndex;
        var waitingToStartBossLevel = false;
        if (gameData.inBossLevel) {
            if (gameData.arrayOfAirplanes.length < 1) {
                // when all boss-level airplanes are resolved, advance to the next level.
                bossLevelComplete();
            } else {
                // while there are active boss-level airplanes, just wait for them all to resolve.
                return;
            }
        }
        if (gameData.arrayOfAirplanes.length < configuration.airplaneSeedTime[currentSeedIndex].max
          && (gameData.nextAirplaneTime == 0 || (currentTime > gameData.nextAirplaneTime))) {
            // it is time to spawn another airplane.
            if (gameData.airplaneSpawns.length < 1) {
                // All airplanes for the current level have been spawned, advance to the next level.
                var nextSeedIndex = currentSeedIndex + 1;
                if (nextSeedIndex < configuration.airplaneSeedTime.length) {
                    if (configuration.airplaneSeedTime[nextSeedIndex].boss) {
                        // if the next level is a boss level, wait until all airplanes are complete before continuing.
                        if (gameData.arrayOfAirplanes.length == 0) {
                            currentSeedIndex += 1;
                            gameData.currentSeedIndex = currentSeedIndex;
                            startBossLevel(gameData.bossLevelIndex + 1, currentTime);
                        } else {
                            waitingToStartBossLevel = true;
                        }
                    } else {
                        // move to next level and generate new spawns
                        if (currentSeedIndex < (configuration.airplaneSeedTime.length - 1)) {
                            currentSeedIndex += 1;
                            gameData.currentSeedIndex = currentSeedIndex;
                            gameData.level += 1;
                        }
                        generateSpawns();
                    }
                } else {
                    generateSpawns();
                }
            }
            if ( ! gameData.inBossLevel && ! waitingToStartBossLevel) {
                createAirplane(currentTime);
                gameData.nextAirplaneTime = currentTime + 1000 + (Math.random() * configuration.airplaneSeedTime[currentSeedIndex].seedTime);
            }
        }
    }

    /**
     * Set up and start a boss level given the level number. Return the boss level that was started,
     * in case the logic is not able to start a boos level and returns 0.
     * @param integer Boss level identifier to indicate which boss level logic to start.
     * @return integer The boss level number that was started, or 0 if no boss level was started.
     */
    function startBossLevel (levelNumber, currentTime) {
        var levelIndex = levelNumber - 1;
        gameData.inBossLevel = true;
        gameData.bossLevelIndex = levelIndex;
        gameData.bossLevelPositionIndex = 0;
        var bossSpawns = configuration.bossLevelSpawnPositions[gameData.bossLevelIndex];
        if (bossSpawns != null) {
            for (var i = 0; i < bossSpawns.length; i ++) {
                createAirplane(currentTime);
            }
        }
        return levelNumber;
    };

    /**
     * End the boss level.
     */
    function bossLevelComplete() {
        gameData.inBossLevel = false;
        gameData.bossLevelIndex += 1;
    };

    function createSprites() {
        var spriteFrames = loader.getResult("game-spriteframes");
        spriteFrames.images = [loader.getResult("game-sprites")];
        spriteFrames.framerate = framerate;
        airplaneSpriteSheet = new createjs.SpriteSheet(spriteFrames);
    }

    function createBackground() {
        var background = stage.getChildByName("background");
        if (background == null) {
            background = new createjs.Shape();
            background.name = "background";
            var backgroundImage = loader.getResult("background");
            var imageWidth = backgroundImage.width;
            var imageHeight = backgroundImage.height;
            var scaleWidth = stageWidth / imageWidth;
            var scaleHeight = stageHeight / imageHeight;
            var scale;
            if (scaleWidth > scaleHeight) {
                scale = scaleWidth;
            } else {
                scale = scaleHeight;
            }
            background.graphics.beginBitmapFill(backgroundImage).drawRect(0, 0, imageWidth, imageHeight);
            background.scaleX = scale;
            background.scaleY = scale;
            background.cache(0, 0, stageWidth, stageHeight);
            stage.addChild(background);
        }
    }

    function createLandingZones() {
        var landingZones = configuration.landingZones;
        var landingZoneShape;
        var landingZoneId = 0;
        var tolerance = 15;
        landingZones.forEach(function(zone) {
            landingZoneId ++;
            var polygon = [];
            var circle;
            landingZoneShape = new createjs.Shape();
            var graphics = landingZoneShape.graphics.beginFill("#000000");
            if (zone.length == 4) {
                // Airplane rectangle
                for (var i = 0; i < zone.length; i ++) {
                    polygon[i] = {x: zone[i].x * scaleFactor, y: zone[i].y * scaleFactor};
                }
                graphics.moveTo(polygon[0].x, polygon[0].y)
                .lineTo(polygon[1].x, polygon[1].y)
                .lineTo(polygon[2].x, polygon[2].y)
                .lineTo(polygon[3].x, polygon[3].y)
                .lineTo(polygon[0].x, polygon[0].y);
                landingZoneShape.polygon = polygon;
                landingZoneShape.circle = null;
                landingZoneShape.landingRotation = angleOfLandingZone(polygon[1], polygon[0]);
                landingZoneShape.landingRotationLow = normalizeAngle(landingZoneShape.landingRotation - tolerance);
                landingZoneShape.landingRotationHigh = normalizeAngle(landingZoneShape.landingRotation + tolerance);
            } else {
                // chopper circle
                circle = {x: zone[0].x * scaleFactor, y: zone[0].y * scaleFactor, r: zone[0].r * scaleFactor};
                graphics.drawCircle(circle.x, circle.y, circle.r);
                landingZoneShape.circle = circle;
                landingZoneShape.polygon = null;
            }
            landingZoneShape.alpha = 0.2;
            landingZoneShape.id = landingZoneId;
            landingZoneShape.landedCount = 0;
            stage.addChild(landingZoneShape);
            arrayOfLandingZones.push(landingZoneShape);
        });
    }

    /**
     * After all game assets are loaded control comes here to initialize the game.
     */
    function handleLoadComplete() {
        gameData.airplaneNextId = 0;
        gameData.currentSeedIndex = 0;
        gameData.level = 1;
        gameData.totalAirplanesSeen = 0;
        gameData.airplaneSpawns = [];
        gameData.nextAirplaneTime = 0;
        createSprites();
        createBackground();
        createLandingZones();
        showGUI();
        generateSpawns();
        createjs.Ticker.addEventListener("tick", onEnterFrame);
        stage.update();
    }

    function distanceBetweenPoints(pointA, pointB) {
        var xDistance = pointB.x - pointA.x;
        var yDistance = pointB.y - pointA.y;
        return Math.sqrt((xDistance * xDistance) + (yDistance * yDistance));
    }

    function distanceBetweenPointsSquared(pointA, pointB) {
        var xDistance = pointB.x - pointA.x;
        var yDistance = pointB.y - pointA.y;
        return (xDistance * xDistance) + (yDistance * yDistance);
    }

    function angleOfObject(xDistance, yDistance) {
        return Math.atan(yDistance / xDistance) * oneEightyPI;
    }

    function angleOfLine(firstPoint, secondPoint) {
        return angleOfObject(secondPoint.x - firstPoint.x, secondPoint.y - firstPoint.y);
    }

    /**
     * Make sure any angle is between 0 and 359 degrees. For example, this will change -5 degrees to 355 degrees
     * and 365 degrees to 5 degrees.
     *
     * @param Number An angle to consider, in degrees.
     * @return Number The adjusted angle if less than 0 or greater than 359. Note 360 is changed to 0.
     */
    function normalizeAngle(angle) {
        while (angle < 0) {
            angle += 360;
        }
        while (angle >= 360) {
            angle -= 360;
        }
        return angle;
    }

    /**
     * Compute the difference between two angles and adjust the difference to the shortest
     * angle of rotation.
     * 
     * @param Number First angle.
     * @param Number Sewcond angle
     * @return Number Difference between the two angles.
     */
    function normalizeAngleDifference(angleA, angleB) {
        var deltaAngle = (angleB - angleA) % 360;
 
        if (deltaAngle > 180) {
            deltaAngle -= 360;
        } else if (deltaAngle < -180) {
            deltaAngle += 360;
        }
        return deltaAngle;
    }

    /**
     * Determine if a point is inside a polygon. Algorithm from https://github.com/substack/point-in-polygon.
     * @param {Point} point is an object with an `x`and `y` property.
     * @param {Array} polygon is an array of objects each with an `x`and `y` property.
     * @return {Boolean} true when the point is inside the polygon.
     */
    function pointInsidePolygon(point, polygon) {
        var i;
        var j;
        var xi;
        var yi;
        var xj;
        var yj;
        var intersect;
        var isInside = false;
        var length = polygon.length;
        var y = point.y;
        for (i = 0, j = length - 1; i < length; j = i ++) {
            xi = polygon[i].x;
            yi = polygon[i].y;
            yj = polygon[j].y;
            intersect = ((yi > y) !== (yj > y)) && (point.x < (polygon[j].x - xi) * (y - yi) / (yj - yi) + xi);
            if (intersect) {
                isInside = ! isInside;
            }
        }
        return isInside;
    }
    
    function slopeMatch(airplane, landingZone) {
        // determine if the slopes match with some degree of tolerance
        if (   (airplane.rotation >= landingZone.landingRotationLow
            &&  airplane.rotation <= landingZone.landingRotationHigh)
            || ((landingZone.landingRotationLow > landingZone.landingRotationHigh)
            && (airplane.rotation >= landingZone.landingRotationLow || airplane.rotation <= landingZone.landingRotationHigh))) {
            // debugLog("Airplane " + airplane.id + " is within tolerance: A.r=" + airplane.rotation + ", L.r=" + landingZone.landingRotationLow + "/" + landingZone.landingRotationHigh);
            return true;
        }
        return false;
    }

    /**
     * Compute the angle of the line segment given an X and Y distance. This is used to
     * adjust the airplane rotation to 4th quadrant, since everything must be mirrored
     * to 0,0 being upper-left, w,h is lower right.
     *
     *        0
     *        |
     * 270 < -+- > 90
     *        |
     *       180
     *
     * @param Airplane airplane The airplane object.
     * @param Number Distance on the X axis.
     * @param Number Distance on the Y axis.
     */
    function angleOfLine(xDistance, yDistance) {
        var angle = angleOfObject(xDistance, yDistance);
        if (xDistance < 0) {
            angle += 90;
        } else {
            angle -= 90;
        }
        return normalizeAngle(angle);
    }

    /**
     * Determine the angle required to align with a landing zone. This is done by
     * looking at the first point, drawing a line to the second point, and matching
     * that angle. This requires landing zones to have their first 2 points set up
     * in this way otherwise this won;t work.
     * @param Point startPoint First point to consider.
     * @param Point endPoint Second point to consider.
     * @return Number Angle determined by A->B.
     */
    function angleOfLandingZone(startPoint, endPoint) {
        var xDistance = endPoint.x - startPoint.x;
        var yDistance = endPoint.y - startPoint.y;
        var angle = angleOfObject(xDistance, yDistance);
        // adjusts to 4th quadrant
        if (xDistance < 0) {
            angle += 90;
        } else {
            angle -= 90;
        }
        return normalizeAngle(angle);
    }

    function collisionDetection() {
        var numberOfAirplanes = gameData.arrayOfAirplanes.length;
        if (numberOfAirplanes < 1) {
            return;
        }
        var planeA;
        var planeB;
        var i;
        var j;
        for (i = 0; i < numberOfAirplanes - 1; i++) {
            planeA = gameData.arrayOfAirplanes[i];
            if (planeA.active && ! planeA.isCrashed && ! planeA.isLanding && ! planeA.isAlignedForLanding()) {
                for (j = i + 1; j < numberOfAirplanes; j++) {
                    planeB = gameData.arrayOfAirplanes[j];
                    if (planeB.active && ! planeB.isCrashed && ! planeB.isLanding) {
                        if (distanceBetweenPoints(planeA, planeB) < (planeA.radius + planeB.radius)) {
                            planeA.setCrashed();
                            planeA.clearFlightPath(null);
                            planeB.setCrashed();
                            planeB.clearFlightPath(null);
                            gameData.totalAirplanesCrashed += 2;
                            updateCrashes();
                            // returning here means no other planes will crash this frame
                            return true; // something crashed
                        }
                    }
                }
            }
        }
        // if we get here the last plane was not checked for landing
        planeA = gameData.arrayOfAirplanes[numberOfAirplanes - 1];
        if (planeA.active && ! planeA.isCrashed && ! planeA.isLanding) {
            planeA.isAlignedForLanding();
        }
        return false; // no crashes
    }

    function onEnterFrame(tickEvent) {
        var deltaTime = tickEvent.delta / 1000;
        updateAirplanePosition(tickEvent.time, deltaTime);
        removeLostAirplanes();
        collisionDetection();
        seedNextAirplane(tickEvent.time, deltaTime);
        stage.update(tickEvent);
    }

    function getFreeAlertContainer() {
        var freeAlertContainer = null;
        for (var index = 0; index < arrayOfAlertContainers.length; index ++) {
            if (arrayOfAlertContainers[index].visible == false) {
                freeAlertContainer = arrayOfAlertContainers[index];
                break;
            }
        }
        if (freeAlertContainer == null) {
            freeAlertContainer = createAlertContainer();
        }
        return freeAlertContainer;
    }

    function showNewAirplaneAlert(airplane) {
        var alertContainer = getFreeAlertContainer();
        var child;
        var airplaneFrame = airplane.sprite.currentAnimation;
        // show a small icon of the airplane
        child = alertContainer.getChildByName("sprite");
        if (child != null) {
            child.gotoAndStop(airplaneFrame);
            child.regX = airplane.width * 0.5;
            child.regY = 0;
            child.scale = 18 / airplane.height;
            child.rotation = 0;
        }
        child = alertContainer.getChildByName("field1");
        if (child != null) {
            child.text = airplane.flightData.carrier + " " + airplane.flightData.flightNumber;
        }
        child = alertContainer.getChildByName("field2");
        if (child != null) {
            child.text = "D: " + airplane.flightData.departing;
        }
        child = alertContainer.getChildByName("field3");
        if (child != null) {
            var minutes = airplane.scheduledArrival.getMinutes();
            child.text = "A: " + airplane.scheduledArrival.getHours() + ":" + (minutes < 10 ? "0" + minutes : minutes);
        }
        alertContainer.x = airplane.x;
        if (alertContainer.x < alertContainer.width) {
            alertContainer.x = 0;
        } else if (alertContainer.x > (stageWidth - alertContainer.width)) {
            alertContainer.x = stageWidth - alertContainer.width;
        }
        alertContainer.y = airplane.y;
        if (alertContainer.y < alertContainer.height) {
            alertContainer.y = 0;
        } else if (alertContainer.y > (stageHeight - alertContainer.height)) {
            alertContainer.y = stageHeight - alertContainer.height;
        }
        alertContainer.visible = true;
        airplane.alertContainer = alertContainer;
        airplane.alertTimeout = window.setTimeout(function() {
            airplane.alertContainer = null;
            airplane.alertTimeout = 0;
            alertContainer.visible = false;
        }, configuration.airplaneSeedTime[gameData.currentSeedIndex].alertTime);
    }

    function createAlertContainer() {
        var height = 60;
        var width = 60;
        var alertContainer = new createjs.Container();
        var graphics = new createjs.Graphics();
        var background = new createjs.Shape(graphics);
        graphics.setStrokeStyle(configuration.airplaneColor.alertColor.strokeWidth);
        graphics.beginStroke(configuration.airplaneColor.alertColor.strokeColor);
        graphics.beginFill(configuration.airplaneColor.alertColor.fillColor);
        graphics.drawRoundRect(0, 0, width, height, 8);
        background.alpha = 0.5;
        alertContainer.addChild(background);
        alertContainer.width = width;
        alertContainer.height = height;

        var airplaneSprite = new createjs.Sprite(airplaneSpriteSheet);
        airplaneSprite.name = "sprite";
        airplaneSprite.x = width * 0.5;
        airplaneSprite.y = height * 0.05;
        alertContainer.addChild(airplaneSprite);

        var textField = new createjs.Text("AA 1111", "bold 10px Arial", "#FFFFFF");
        textField.maxWidth = width * 0.98;
        textField.name = "field1";
        textField.textAlign = "center";
        textField.textBaseline = "middle";
        textField.x = width * 0.5;
        textField.y = height * 0.5;
        alertContainer.addChild(textField);

        textField = new createjs.Text("D: AAA", "bold 10px Arial", "#FFFFFF");
        textField.maxWidth = width * 0.98;
        textField.name = "field2";
        textField.textAlign = "center";
        textField.textBaseline = "middle";
        textField.x = width * 0.5;
        textField.y = height * 0.68;
        alertContainer.addChild(textField);

        textField = new createjs.Text("A: 99:99", "bold 10px Arial", "#FFFFFF");
        textField.maxWidth = width * 0.98;
        textField.name = "field3";
        textField.textAlign = "center";
        textField.textBaseline = "middle";
        textField.x = width * 0.5;
        textField.y = height * 0.86;
        alertContainer.addChild(textField);

        arrayOfAlertContainers.push(alertContainer);
        stage.addChild(alertContainer);

        return alertContainer;
    }

    function showFlightStatus(airplane) {
        var statusElement = document.getElementById("statusMessage");
        if (statusElement != null) {
            statusElement.innerText = "Now entering your air space: " + airplane.flightData.carrier + " flight " + airplane.flightData.flightNumber + " departed from " + airplane.flightData.departing;
        }
        showNewAirplaneAlert(airplane);
    }
    </script>
    <style>
        html, body {
            left: 0;
            top: 0;
            margin: 0;
            padding:0;
            width: 100%;
            height: 100%;
        }
        #myCanvas {
            left: 0;
            top: 0;
            margin: 0;
            padding:0;
            width: 100%;
            height: 100%;
        }
    </style>
</head>

<body onload="init();">
    <canvas id="myCanvas" width="1024" height="768"></canvas>
</body>
</html>
